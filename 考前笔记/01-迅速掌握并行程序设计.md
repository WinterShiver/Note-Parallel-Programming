# 迅速掌握并行程序设计

## CH 1 基本知识

### 概念速查
高性能计算机，高性能服务器，高性能计算
任务并行，数据并行
共享内存，分布式内存

### 高性能
高性能 High Performance：方向包括系统/应用，高性能CPU/IO

设备 | 任务 | 任务特点
---- | ---- | ----
高性能计算机 | 超大规模or复杂，计算or数据处理 | CPU密集
高性能服务器 | 网络服务，事务处理 | IO密集

### 计算科学
和理论科学，实验科学并列
理论+计算模拟仿真+实验验证，中间那步

### 并行计算
历史：不能挤主频的牙膏（因为功耗），变成多核处理器，只有并行才能利用；不能全靠前人开发的自动转并行程序

**任务并行**：将解决问题需要执行的各个计算任务分配到各个核上
**数据并行**：将解决问题需要处理的数据分配到各个核上，每个核任务类似

在多个核之间需要协调工作时，程序难编，要做到**通信，负载平衡，同步**

### 并行系统
* **共享内存**
  * 通过共享内存数据来协调各个核，通过访问相同的数据进行隐式通信
  * 技术举例：OpenMP，PThreads（POSIX线程）
* **分布式内存**
  * 每个核具有自己的内存，通过网络发消息进行显式通信
  * 技术举例：MPI（写MPI很有感受）

### 计算概念辨析
* **并发计算**：跟单核多进程or多线程很像，伪并行，微观上串行，只是这些任务同时执行
* **并行计算**：多个任务紧耦合，协作完成一个任务，是我们考虑的重点，写的程序都像那样
* **分布式计算**：不同程序之间有些通信，但松耦合

### 求解全局和
树状求和：要会算“数据接收，数据计算”次数

## CH 2-1 改进计算效率的几个级别

### 概念速查
冯诺依曼结构，冯诺依曼瓶颈
进程和线程，局部性原理
Cache映射，不一致

### 改进计算效率
（知识+逻辑）
纯知识：冯诺依曼结构，进程和线程，局部性原理，Cache
改进逻辑：
* 利用Cache改进冯诺依曼结构：读Cache比读内存快，瓶颈没有那么紧
* 指令级并行：
  * 流水线：多个功能单元同时执行指令
  * 多发射：多个硬件~，为此有多套相同部件
  * 超标量：多个流水线，所以和流水线和多发射都有很大关系
* 线程级并行：
  * 粗粒度：线程需要等待很长时间才能完成操作而被阻塞，这样可以换。缺点：短阻塞，时间还是浪费了
  * 细粒度：每执行一条指令，可以换。缺点：每执行一条指令都要等
  * 同步多线程：应用超标量，细粒度多线程+多个功能单元并行


### 冯诺依曼结构
CPU-总线-主存（CPU为核心）
**冯诺依曼瓶颈**：指令所用数据通过总线load-store，100倍慢于执行数据

### 进程和线程
* **进程**：运行着的程序
  * 保存的信息包括：程序，内存，资源描述符，状态&安全信息
  * 多任务：多进程
  * 进程阻塞：等资源
* **线程**：单线程进程，多线程进程，将程序划分为多个任务，某个线程阻塞时其他线程还可以继续

### 局部性原理
about访存
时间局部性：同一区域不久后就访，且多次
空间局部性：下一次更可能访临近区域

### Cache
Cache：缓存（esp.CPU缓存，esp.和CPU在同一块芯片上）
* 速度：Cache>内存>外存
* 存储：以块存储（所以局部性）
* 映射：全相连，组相连，直接映射（
* Cache的命中缺失
* Cache和内存的不一致及解决策略：写直达，写回
* 不同核Cache的不一致：监听Cache一致性协议（总线+广播，不提倡），基于目录的Cache一致性协议（改过的置为非法）
  * 伪共享：核之间以为数据脏了而从内存读数据，但其实没影响，导致Cache没有发挥作用

## CH 2-2 并行硬件

### 概念速查

### 并行硬件及分类
并行硬件：程序员可见的硬件，通过写代码在其上实现并行
* Flynn：指令流？（I）数据流？（D）单or多？（S/M）
  * SIMD：主要是数据并行，对数据执行相同指令，一个控制+多个ALU
    * ALU必须同时干活或不干，有的时候没有指令存储器，必须同步
    * 优点：大量数据计算，缺点：其他复杂任务
  * **MIMD**：每个处理单元都有自己的控制+ALU，有很多套处理单元
    * 一般异步
* 内存与互联网络
  * 共享内存
    * 一致内存访问（记住图，核-芯片-内存，通信通过内存）
    * 不一致内存访问（记住图，核-芯片-不同内存，通信通过核）
    * 互联网络
      * 总线：共享的通信线，回顾调度那一套，低成本灵活，但太多冲突可能性能下降
      * 交叉开关矩阵：不冲突，速度快，但线多贵
  * 分布式内存（记住图，处理器-内存是一体单元，其间互联，以下记p个单元）
    * 直接互联：交换器与单元一对一（计入链路总数），交换机互联
      * 连接方式：环，矩形
      * 链路数：（2p，3p）
      * 等分宽度：（2,2$\sqrt{p}$）
    * 间接互联：单向边，单元一进一出，黑箱里面是交换器结点（回忆图）
      * 交叉开关矩阵：回忆图（右上），交换器$p^2$，等分宽度p
      * omega：没看懂，记住$2plog_2p$，$p/2$
    * 等分宽度：同时通信的链路数目
      * 用于衡量连接性：密稳定or疏易崩
      * 等分宽度计算：去最少的链路使等分
* 延迟和带宽：延迟+大小/带宽（l+n/b）
  * 延迟：从发送端开始传送到接收端开始接收 

## CH 2-3 并行软件

### 概念速查

### 逻辑
* 共享内存：单进程多线程，线程对应任务
* 分布式内存：多进程，进程对应任务
* 确实很对应

### 编程思路
* 单程序多数据流（SPMD）
  * in which：一段程序，**针对进程号if-else**，让不同的进程or线程做不同的事情（想MPI）
  * 任务并行：不同任务；数据并行：不同数据
  * 虽然单程序但其实已经是多指令多数据流（MIMD）了
* 编程思路
  * **分配任务**：大致相等
  * **同步**
  * **通信**：通信尽量少

### 共享内存编程
* 动态线程
  * 主线程一直run，来一个任务建一个子线程，子线程完成任务之后再合并回去
  * 优点：节省资源，缺点：线程创建终止费时
* 静态线程
  * 线程池，整个任务结束之前所有线程都在运行，最后再一个个清理
  * 优点：性能好，缺点：费资源）
 * 一个常见问题：结果的非确定性
   * 异步导致输出结果顺序不确定，解决：对输入输出的设计
     * 只有主进程接收输入，所有进程可输出，但正常情况下只有一个进程输出
     * 输出时，标记是谁输出的
     * 其他文件：只有一个进程访问
   * 异步+共享内存导致结果写乱了，解决：临界区+互斥锁
     * 临界区：只能被一个线程执行的代码块
     * lock和unlock之间是临界区
     * 互斥锁的设计：循环测试一个条件（代码？）
### 分布式内存编程
至少要有send和recv可用（具体接口长啥样？想MPI）

### 计算加速比
* 概念
  * 理论上的并行加速比：p，因为用p个核
  * 实际加速比：S，效率：S/p
    * 跟：问题规模n，核数p有关
* 实际上达不到：因为工作不均匀，额外工作，导致p<1
  * 形式化表示开销：要用<=，因为实际情况可能更慢（$\sigma,\phi,\kappa$）
  * 加速比-核数曲线：反对勾，有峰值
  * 效率-核数曲线：递减
  * Amdahl定律：靠堆核并行加速，有上限
  * Amdahl效应：规模上去时，一般平摊串行比例变少，加速比提高
  * Gustafson-Barsis：原s+(1-s)p，现s+(1-s)
* 可扩展性
  * 线程or进程数*n，规模*n，效率保持不变
  * 强：规模不用增，弱：规模需要增

### 计时
* 并行程序计时
  * 对一部分代码记起止时间计时
  * 同步+取最长
  * 多次+取平均or最短
  * 因为计时由CPU提供，所以不推荐在一个核上跑多个线程，使时间失去意义
  * 通常不包括IO时间

### 任务-通道模型
Ian Foster的并行程序设计方法论，这个好抽象啊
* 任务，通道
  * 任务：进程+IO
  * 通道：任务间通信用的消息队列
  * 发送异步，接收同步
 * 划分，通信，聚集，映射
   * 划分：发现可并行的部分，进行数据分解or模型分解
     * 数据分解：拆主要费时的部分
     * 模型分解：流水线好
     * 划分质量评估：原始任务数多于核数（高一个数量级），少冗余，平衡，任务数正相关规模（多于核数）
     （原始任务数：可并行的任务数的上界）
   * 通信：属于合并，所以重点是减少并行开销
     * 尽量少通信：只和临近进程or特定进程通信，平衡，并发通信，并发计算
   * 合并：属于合并，所以重点是减少并行开销
     * 尽量少通信：低耦合，有依赖关系的这些东西都放在一个任务里面，减少通信次数
     * 保证可扩展性
     * 减少开发难度：能用的串行大胆用
     * 平均，局部性
   * 映射：把任务分配给处理器
     * 固定映射，动态负载均衡（集中式，分布式：统一管理or每个工人有策略）
* 实例分析：真tm难
